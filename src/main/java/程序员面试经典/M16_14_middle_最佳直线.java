package 程序员面试经典;

/**
 * @author : alfredt
 * @version : 1.0.0
 * @date : Created in 2020/9/23 10:43 上午
 * @description : 面试题 16.14. 最佳直线
 * @modified By  :
 * 给定一个二维平面及平面上的 N 个点列表Points，其中第i个点的坐标为Points[i]=[Xi,Yi]。请找出一条直线，其通过的点的数目最多。
 * <p>
 * 设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为S，你仅需返回[S[0],S[1]]作为答案，若有多条直线穿过了相同数量的点，则选择S[0]值较小的直线返回，S[0]相同则选择S[1]值较小的直线返回。
 * <p>
 * 示例：
 * <p>
 * 输入： [[0,0],[1,1],[1,0],[2,0]]
 * 输出： [0,2]
 * 解释： 所求直线穿过的3个点的编号为[0,2,3]
 * 提示：
 * <p>
 * 2 <= len(Points) <= 300
 * len(Points[i]) = 2
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/best-line-lcci
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class M16_14_middle_最佳直线 {

    public static void main(String[] args) {
        bestLine(new int[][]{{23064, -1044}, {0, 22969}, {17805, 40898}, {29725, -1778}, {-32070, -2148}, {-19027, -2055}, {-679, -41065}, {12043, -16880}, {21838, 13404}, {22690, -6475}, {21585, -19101}, {7577, -14359}, {-20014, -40714}, {20942, -19286}, {12648, 21299}, {-36169, -11846}, {3595, -19224}, {27974, 26651}, {25899, 12871}, {-13881, -24276}, {16833, -19449}, {-13881, 5948}, {-48591, 29692}, {17406, -39601}, {24765, 7305}, {-41894, -12128}, {13645, -12514}, {17119, -45877}, {27715, -3120}, {10537, -33802}, {-36719, -39521}, {3328, -16834}, {25332, 10088}, {-23069, -31890}, {4192, 28773}, {20987, -7179}, {29525, -25688}, {-5450, -25263}, {-14571, -26940}, {-31236, 17820}, {-2435, -23250}, {28720, -2449}, {5905, 7021}, {-48683, -2355}, {-64140, -27265}, {20829, -17796}, {21104, 13825}, {-30954, -26421}});
    }

    public static int[] bestLine(int[][] points) {
        int max = 0, s0 = 0, s1 = 0;
        for (int i = 0; i < points.length; i++) {
            for (int j = i + 1; j < points.length; j++) {
                int temp = 2, ts0 = i, ts1 = j;
                int x1 = points[j][0] - points[i][0];
                int y1 = points[j][1] - points[i][1];
                for (int k = j + 1; k < points.length; k++) {
                    int x2 = points[k][0] - points[i][0];
                    int y2 = points[k][1] - points[i][1];
                    if (x1 * y2 == y1 * x2) {
                        temp++;
                    }
                }
                if (temp > max) {
                    max = temp;
                    s0 = ts0;
                    s1 = ts1;
                }
            }
        }
        return new int[]{s0, s1};
    }


}
